"""
Program to:
1) Generate the global matrix containing all the contact matrices (intra and inter)
for all the chromosomes to be normalized using "HiCtool_run_ic_mes.sh".
2) Plot the global contact matrix or the a single contact matrix.

To use this code, an HiC_project_object.hdf5 must be provided (see HiCtool_hifive.py)
"""

chromosomes = {'hg38':{'1':248956422,
                   '2':242193529,
                   '3':198295559,
                   '4':190214555,
                   '5':181538259,
                   '6':170805979,
                   '7':159345973,
                   '8':145138636,
                   '9':138394717,
                   '10':133797422,
                   '11':135086622,
                   '12':133275309,
                   '13':114364328,
                   '14':107043718,
                   '15':101991189,
                   '16':90338345,
                   '17':83257441,
                   '18':80373285,
                   '19':58617616,
                   '20':64444167,
                   '21':46709983,
                   '22':50818468,
                   'X':156040895,
                   'Y':57227415},
                   'mm10':{'1':195471971,
                   '2':182113224,
                   '3':160039680,
                   '4':156508116,
                   '5':151834684,
                   '6':149736546,
                   '7':145441459,
                   '8':129401213,
                   '9':124595110,
                   '10':130694993,
                   '11':122082543,
                   '12':120129022,
                   '13':120421639,
                   '14':124902244,
                   '15':104043685,
                   '16':98207768,
                   '17':94987271,
                   '18':90702639,
                   '19':61431566,
                   'X':171031299,
                   'Y':91744698}}  


def save_matrix_rectangular(a_matrix, output_file):
    """
    Save an inter-chromosomal contact matrix in the HiCtool compressed format to txt file.
    1) Data are reshaped to form a vector.
    2) All the consecutive zeros are replaced with a "0" followed by the
    number of times zeros are repeated consecutively.
    3) Data are saved to a txt file.
    Arguments:
        a_matrix (numpy matrix): input contact matrix to be saved
        output_file (str): output file name in txt format
    Output:
        txt file containing the formatted data
    """
    import numpy as np
    n_row = np.shape(a_matrix)[0]
    n_col = np.shape(a_matrix)[1]
    vect = np.reshape(a_matrix,[1,n_row*n_col]).tolist()[0]
    with open (output_file,'w') as fout:
        k = len(vect)
        i = 0
        count = 0
        flag = False # flag to set if the end of the vector has been reached
        while i < k and flag == False:
            if vect[i] == 0:
                count+=1
                if (i+count == k):
                    w_out = str(0) + str(count)
                    fout.write('%s\n' %w_out)
                    flag = True
                    break
                while vect[i+count] == 0 and flag == False:
                    count+=1
                    if (i+count == k):
                        w_out = str(0) + str(count)
                        fout.write('%s\n' %w_out)
                        flag = True
                        break
                if flag == False:
                    w_out = str(0) + str(count)
                    fout.write('%s\n' %w_out)
                    i+=count
                    count = 0
            else:
                fout.write('%s\n' %vect[i])
                i+=1 


def load_matrix_rectangular(input_file, n_row, n_col):
    """
    Load an HiCtool compressed rectangular contact matrix from a txt file and parse it.
    Arguments:
        input_file (str): input file name in txt format (generated by the function 
        "save_matrix_rectangular")
        n_row (int): number of rows of the matrix.
        n_col (int): number of columns of the matrix.
    Return: 
        output_matrix: numpy array the parsed values stored in the input txt file to build a contact matrix.        
    """
    import numpy as np    
    
    print "Loading " + input_file + "..."
    with open (input_file,'r') as infile:
        matrix_vect = []        
        for i in infile:
            if i[0] == "0" and i[1] != ".":
                for k in xrange(int(i[1:-1])):
                    matrix_vect.append(0)
            else:
                j = i[:-1]            
                matrix_vect.append(float(j))
  
    output_matrix = np.reshape(np.array(matrix_vect),[n_row,n_col])
    print "Done!"
    return output_matrix
   

def save_matrix(a_matrix, output_file):
    """
    Save an intra-chromosomal contact matrix in the HiCtool compressed format to txt file.
    1) The upper-triangular part of the matrix is selected (including the
    diagonal).
    2) Data are reshaped to form a vector.
    3) All the consecutive zeros are replaced with a "0" followed by the
    number of times zeros are repeated consecutively.
    4) Data are saved to a txt file.
    Arguments:
        a_matrix (numpy matrix): input contact matrix to be saved
        output_file (str): output file name in txt format
    Output:
        txt file containing the formatted data
    """
    import numpy as np
    n = len(a_matrix)
    iu = np.triu_indices(n)
    vect = a_matrix[iu].tolist()
    with open (output_file,'w') as fout:
        k = len(vect)
        i = 0
        count = 0
        flag = False # flag to set if the end of the vector has been reached
        while i < k and flag == False:
            if vect[i] == 0:
                count+=1
                if (i+count == k):
                    w_out = str(0) + str(count)
                    fout.write('%s\n' %w_out)
                    flag = True
                    break
                while vect[i+count] == 0 and flag == False:
                    count+=1
                    if (i+count == k):
                        w_out = str(0) + str(count)
                        fout.write('%s\n' %w_out)
                        flag = True
                        break
                if flag == False:
                    w_out = str(0) + str(count)
                    fout.write('%s\n' %w_out)
                    i+=count
                    count = 0
            else:
                fout.write('%s\n' %vect[i])
                i+=1     


def load_matrix(input_file):
    """
    Load an HiCtool compressed square (and symmetric) contact matrix from a txt file and parse it.
    Arguments:
        input_file (str): input file name in txt format (generated by the function 
        "save_matrix").
    Return: 
        numpy array containing the parsed values stored in the input txt file to build a contact matrix.      
    """
    import numpy as np    
    
    print "Loading " + input_file + "..."
    with open (input_file,'r') as infile:
        matrix_vect = []        
        for i in infile:
            if i[0] == "0" and i[1] != ".":
                for k in xrange(int(i[1:-1])):
                    matrix_vect.append(0)
            else:
                j = i[:-1]            
                matrix_vect.append(float(j))
  
    k = len(matrix_vect)
    matrix_size = int((-1+np.sqrt(1+8*k))/2)
    
    iu = np.triu_indices(matrix_size)
    output_matrix_1 = np.zeros((matrix_size,matrix_size)) # upper triangular plus the diagonal
    output_matrix_1[iu] = matrix_vect
    
    diag_matrix = np.diag(np.diag(output_matrix_1)) # diagonal
    output_matrix_2 = np.transpose(output_matrix_1) # lower triangular plus the diagonal
    output_matrix = output_matrix_1 + output_matrix_2 - diag_matrix
    print "Done!"
    return output_matrix
    
    
def save_matrix_tab(input_matrix, output_filename):
    """
    Save a contact matrix in a txt file in a tab separated format. Columns are
    separated by tabs, rows are in different lines.
    Arguments:
        input_matrix (numpy matrix): input contact matrix to be saved
        output_filename (str): output file name in txt format
    Output:
        txt file containing the tab separated data
    """
    with open (output_filename, 'w') as f:
            for i in xrange(len(input_matrix)):
                row = [str(j) for j in input_matrix[i]]
                if i != len(input_matrix) - 1:
                    f.write('\t'.join(row) + '\n')
                else:
                    f.write('\t'.join(row))
                    
                    
def load_matrix_tab(input_file):
    """
    Load a contact matrix saved in a tab separated format using the function
    "save_matrix_tab".
    Arguments:
        input_file (str): input contact matrix to be loaded.
    Return: 
        numpy array containing the parsed values stored in the input tab separated txt file to build a contact matrix.
    """
    import numpy as np
    
    print "Loading " + input_file + "..."
    with open (input_file, 'r') as infile:
        lines = infile.readlines()
        temp = []
        for line in lines:
            row = [float(i) for i in line.strip().split('\t')]
            temp.append(row)
            
        output_matrix = np.array(temp)
    print "Done!"
    return output_matrix


def load_topological_domains(input_file):
    """
    Function to load the topological domains coordinates from txt file.
    Arguments:
        input_file (str): input file name generated with "calculate_topological_domains" in txt format.
    Return:
        List of lists with topological domain coordinates.
    """
    import csv
    print "Loading topological domain coordinates..."
    with open(input_file, 'r') as f:
        reader = csv.reader(f, dialect='excel', delimiter='\t')
        topological_domains = []
        for row in reader:
            row_int = [int(x) for x in row]
            topological_domains.append(row_int)
        print "Done!"
        return topological_domains

 
def generate_intrachromosomal_observed_data(a_chr,
                                            bin_size,
                                            input_file='HiC_project_object.hdf5',
                                            species='hg38',
                                            custom_species=None,
                                            save_file=False):
    """
    Generate an observed intrachromosomal contact matrix from HiC_project_object.hdf5.
    Arguments:
        a_chr (str): chromosome number (example for chromosome 1: '1').
        bin_size (int): bin size in bp of the contact matrix.
        input_file (str): object containing learned correction parameters in .hdf5 format obtained with
        HiCtool_hifive.py (default: 'HiC_project_object.hdf5').
        species (str): 'hg38' or 'mm10' or any other species label in string format.
        custom_species (str): "/path/filename.txt". Tab separated file for chromosomes of the custom species. 
        Each row of the file is a chromosome: first column chromosome name with chr label (example:chrA); 
        second column chromosome size.
        save_file (bool): if true, save the observed contact data.
    Return: 
        observed intrachromosomal contact matrix in numpy array format.
    Output: 
        observed intrachromosomal contact matrix in HiCtool compressed format if "save_file=True".
    """
    import hifive
    
    chromosome = 'chr' + a_chr
    
    if bin_size >= 1000000:
        bin_size_str = str(bin_size/1000000)
        output_filename = 'HiCtool_' + chromosome + '_' + bin_size_str + 'mb_' + 'observed_fend'
    elif bin_size < 1000000:
        bin_size_str = str(bin_size/1000)
        output_filename = 'HiCtool_' + chromosome + '_' + bin_size_str + 'kb_' + 'observed_fend'    
    
    if species in chromosomes.keys():
        end_pos = (chromosomes[species][a_chr]/bin_size)*bin_size
    else:
        custom_chromosomes = open(custom_species, 'r')
        chromosomes_list = []
        chr_dim = []
        d_chr_dim = {}
        while True:
            try:
                line2list = next(custom_chromosomes).split('\n')[0].split('\t')
                chromosomes_list.append(line2list[0].replace('chr',''))
                chr_dim.append(int(line2list[1])/bin_size) 
                d_chr_dim[line2list[0].replace('chr','')] = int(line2list[1])/bin_size
            except StopIteration:
                break
        end_pos = (d_chr_dim[a_chr]/bin_size)*bin_size
            
    hic = hifive.HiC(input_file)
    heatmap_raw = hic.cis_heatmap(chrom=chromosome,
                                  start=0,
                                  stop=end_pos,
                                  binsize=bin_size,
                                  arraytype='full',
                                  datatype='raw')
    
    observed = heatmap_raw[:,:,0]
    
    if save_file == True:
        save_matrix(observed, output_filename + '.txt')  
    return observed


def generate_interchromosomal_observed_data(chr_row,
                                            chr_col,
                                            bin_size,
                                            input_file='HiC_project_object.hdf5',
                                            species='hg38',
                                            custom_species=None,
                                            save_file=False):
    """
    Generate an observed interchromosomal contact matrix from HiC_project_object.hdf5
    Arguments:
        chr_row (str): chromosome number for the rows (example for chromosome 1: '1').
        chr_col (str): chromosome number for the columns (example for chromosome 1: '1').
        bin_size (int): bin size in bp of the contact matrix.
        input_file (str): object containing learned correction parameters in hdf5 format obtained with
        HiCtool_hifive.py (default: 'HiC_project_object.hdf5').
        species (str): 'hg38' or 'mm10' or any other species label in string format.
        custom_species (str): "/path/filename.txt". Tab separated file for chromosomes of the custom species. 
        Each row of the file is a chromosome: first column chromosome name with chr label (example:chrA); 
        second column chromosome size.
        save_file (bool): if True, save the observed contact data.
    Return: 
        observed interchromosomal contact matrix in numpy array format.
    Output: 
        observed interchromosomal contact matrix in HiCtool compressed format if "save_file=True".
    """
    import hifive
    
    chromosome_row = 'chr' + chr_row
    chromosome_col = 'chr' + chr_col
    
    if bin_size >= 1000000:
        bin_size_str = str(bin_size/1000000)
        output_filename = 'HiCtool_' + chromosome_row + '_' + chromosome_col + '_' + bin_size_str + 'mb_'
    elif bin_size < 1000000:
        bin_size_str = str(bin_size/1000)
        output_filename = 'HiCtool_' + chromosome_row + '_' + chromosome_col + '_' + bin_size_str + 'kb_'    
    
    if species in chromosomes.keys():
        end_pos_row = (chromosomes[species][chr_row]/bin_size)*bin_size
        end_pos_col = (chromosomes[species][chr_col]/bin_size)*bin_size
    else:
        custom_chromosomes = open(custom_species, 'r')
        chromosomes_list = []
        chr_dim = []
        d_chr_dim = {}
        while True:
            try:
                line2list = next(custom_chromosomes).split('\n')[0].split('\t')
                chromosomes_list.append(line2list[0].replace('chr',''))
                chr_dim.append(int(line2list[1])/bin_size) 
                d_chr_dim[line2list[0].replace('chr','')] = int(line2list[1])/bin_size
            except StopIteration:
                break
        end_pos_row = (d_chr_dim[chr_row]/bin_size)*bin_size
        end_pos_col = (d_chr_dim[chr_col]/bin_size)*bin_size
            
    hic = hifive.HiC(input_file)
    heatmap_raw = hic.trans_heatmap(chromosome_row, chromosome_col, 
                                    start1=0, stop1=end_pos_row, 
                                    start2=0, stop2=end_pos_col,
                                    binsize=bin_size, 
                                    datatype='raw')
    
    observed = heatmap_raw[:,:,0]
    #row = observed.shape[0]
    #col = observed.shape[1]
    
    if save_file == True:
        #row_str = str(row)
        #col_str = str(col)
        #output_filename = output_filename + row_str + 'x' + col_str + '_'
        save_matrix_rectangular(observed, output_filename + 'observed.txt')
    return observed


def compute_matrix_data_full_observed(input_file='HiC_project_object.hdf5',
                                      bin_size=1000000,
                                      species='hg38',
                                      custom_species=None,
                                      save_each_matrix=False,
                                      save_tab=True):
    """
    Generate the full observed contact matrix for all the chromosomes from HiC_project_object.hdf5.
    The matrix will contain all the chromosomes in the rows and in the columns, each entry i,j is the contact
    matrix associated to the chromosomes in row i and column j (either intra- or inter-chromosomal).
    Arguments:
        input_file (str): object containing learned correction parameters in hdf5 format obtained with
        HiCtool_hifive.py (default: 'HiC_project_object.hdf5').
        bin_size (int): bin size in bp of the contact matrix.
        species (str): 'hg38' or 'mm10' or any other species label in string format.
        custom_species (str): "/path/filename.txt". Tab separated file for chromosomes of the custom species. 
        Each row of the file is a chromosome: first column chromosome name with chr label (example:chrA); 
        second column chromosome size.
        save_each_matrix (bool): if True, save each single contact matrix in formatted txt file.
        save_tab (bool): if True, save the full observed matrix in tab separated format. This is
        needed to proceed with normalization using Hi-Corrector.
    Return: 
        Global matrix in numpy array format.
    Outputs:
        Txt file with the global matrix in HiCtool compressed format.
        Txt files with each single contact matrix in HiCtool compressed format if "save_each_matrix=True".
        Txt file with the global matrix saved in tab separated format if "save_tab=True".
    """
    import numpy as np
    #sep_tick = 1 # width of the grid lines in pts
    #global matrix_global
    #global matrix_global_plot
    
    if species in chromosomes.keys():
        chromosomes_list = [str(i) for i in range(len(chromosomes[species]) - 1)[1:]] + ['X', 'Y']
    else:
        custom_chromosomes = open(custom_species, 'r')
        chromosomes_list = []
        while True:
            try:
                line2list = next(custom_chromosomes).split('\n')[0].split('\t')
                chromosomes_list.append(line2list[0].replace('chr',''))
            except StopIteration:
                break
    
    for chr_row in chromosomes_list:
        chromosome_row = 'chr' + chr_row
        if chromosome_row == 'chr1':
            intra = generate_intrachromosomal_observed_data(chr_row,bin_size,input_file,species,custom_species,save_each_matrix)
            matrix_full_line = intra
            #matrix_full_line_plot = intra
        
        for chr_col in chromosomes_list:
            chromosome_col = 'chr' + chr_col
            
            if chromosome_row == chromosome_col and chromosome_row == 'chr1':
                continue
        
            elif chromosome_row == chromosome_col and chromosome_row != 'chr1':
                intra = generate_intrachromosomal_observed_data(chr_row,bin_size,input_file,species,custom_species,save_each_matrix)
                n_row = np.shape(intra)[0]
                #sep_col = np.zeros((n_row,sep_tick))-1
                matrix_full_line = np.concatenate((matrix_full_line,intra),axis=1)
                #matrix_full_line_plot = np.concatenate((matrix_full_line_plot,sep_col,intra),axis=1)
                    
            else:
                row = (chromosomes[species][chr_row]/bin_size)*bin_size/bin_size
                col = (chromosomes[species][chr_col]/bin_size)*bin_size/bin_size
                row_str = str(row)
                col_str = str(col)
    
                matrix_data_full = generate_interchromosomal_observed_data(chr_row,chr_col,bin_size,input_file,species,custom_species,save_each_matrix)
                n_row = np.shape(matrix_data_full)[0]
                #sep_col = np.zeros((n_row,sep_tick))-1
                
                if 'matrix_full_line' in locals():
                    matrix_full_line = np.concatenate((matrix_full_line,matrix_data_full),axis=1)
                    #matrix_full_line_plot = np.concatenate((matrix_full_line_plot,sep_col,matrix_data_full),axis=1)
                else:
                    matrix_full_line = matrix_data_full
                    #matrix_full_line_plot = matrix_data_full
                   
        #n_col = np.shape(matrix_full_line_plot)[1]
        #sep_row = np.zeros((sep_tick,n_col))-1
        
        if chromosome_row == 'chr1':
            matrix_global = matrix_full_line
            #matrix_global_plot = matrix_full_line_plot
        else:
            matrix_global = np.concatenate((matrix_global,matrix_full_line))
            #matrix_global_plot = np.concatenate((matrix_global_plot,sep_row,matrix_full_line_plot))
            
        del(matrix_full_line)
        #del(matrix_full_line_plot)
    
    if bin_size >= 1000000:
        bin_size_str = str(bin_size/1000000)
        my_filename = 'HiCtool_' + bin_size_str + 'mb_'
    elif bin_size < 1000000:
        bin_size_str = str(bin_size/1000)
        my_filename = 'HiCtool_' + bin_size_str + 'kb_'
    
    save_matrix(matrix_global, my_filename + 'matrix_global_observed.txt') # without grid
    #save_matrix(matrix_global_plot, my_filename + 'matrix_global_observed_to_plot.txt') # with grid
    
    # Save the full observed matrix into a tab separated format
    if save_tab == True:
        save_matrix_tab(matrix_global, my_filename + 'matrix_global_observed_tab.txt')
                
    with open ('info.txt', 'w') as f:
        f.write('Rows: ' + str(len(matrix_global)) + '\n')
        f.write('Rowsum (average matrix * rows): ' + str(int(np.mean(matrix_global) * len(matrix_global))))
    
    return matrix_global
                
                
def extract_single_map(input_global_matrix,
                       tab_sep,
                       chr_row,
                       chr_col,
                       species='hg38',
                       bin_size=1000000,
                       data_type='observed',
                       custom_species=None,
                       save_output=True,
                       save_tab=False):
    """
    Extract a single contact matrix for a pair of chromosomes from the global matrix (all-by-all chromosomes).
    Arguments:
        input_global_matrix (object | str): global contact matrix. This can be passed either as
        an object of the workspace or a string of the filename saved to file.
        tab_sep (bool): if "input_global_matrix" is passed with a filename, then this boolean 
        tells if the global matrix was saved in tab separated format (True) or not (False).
        chr_row (str): chromosome in the rows of the output contact matrix.
        chr_col (str): chromosome in the columns of the output contact matrix. If chr_col is 
        equal to chr_row then the intra-chromosomal map is extracted.
        species (str): 'hg38' or 'mm10' or any other species label in string format.
        bin_size (int): bin size in bp of the contact matrix.
        data_type (str): which kind of data type you are extracting: "observed" or "normalized".
        custom_species (str): "/path/filename.txt". Tab separated file for chromosomes of the custom species. 
        Each row of the file is a chromosome: first column chromosome name with chr label (example:chrA); 
        second column chromosome size.
        save_output (bool): if True, save the contact matrix in HiCtool compressed txt file.
        save_tab (bool): if True, save the contact matrix in tab separated format.
    Return: 
        Contact matrix in numpy array format.
    Outputs:
        Txt file with the contact matrix in HiCtool compressed format if "save_output=True".
        Txt file with the contact matrix in tab separated format if "save_tab=True".
    """            
    if species in chromosomes.keys():
        chromosomes_list = [str(i) for i in range(len(chromosomes[species]) - 1)[1:]] + ['X', 'Y']
        chr_dim = []
        for i in chromosomes_list:
            chr_dim.append(chromosomes[species][i]/bin_size) 
        d_chr_dim = {}
        for i in chromosomes_list:
            d_chr_dim[i] = chromosomes[species][i]/bin_size
    else:
        custom_chromosomes = open(custom_species, 'r')
        chromosomes_list = []
        chr_dim = []
        d_chr_dim = {}
        while True:
            try:
                line2list = next(custom_chromosomes).split('\n')[0].split('\t')
                chromosomes_list.append(line2list[0].replace('chr',''))
                chr_dim.append(int(line2list[1])/bin_size) 
                d_chr_dim[line2list[0].replace('chr','')] = int(line2list[1])/bin_size
            except StopIteration:
                break
    
    d_chr_dim_inc = {}
    k=1
    for i in chromosomes_list:
        d_chr_dim_inc[i] = sum(chr_dim[:k])
        k+=1
    
    if isinstance(input_global_matrix,str):
        if tab_sep == False:
            full_matrix = load_matrix(input_global_matrix)
        else:
            full_matrix = load_matrix_tab(input_global_matrix)
    else:
        full_matrix = input_global_matrix
    
    if chr_row == '1':
        row_start = 0
    else:
        row_start = d_chr_dim_inc[chromosomes_list[chromosomes_list.index(chr_row)-1]]
    row_end = row_start + d_chr_dim[chr_row]
    
    if chr_col == '1':
        col_start = 0
    else:
        col_start = d_chr_dim_inc[chromosomes_list[chromosomes_list.index(chr_col)-1]]
    col_end = col_start + d_chr_dim[chr_col]
    
    output_matrix = full_matrix[row_start:row_end,col_start:col_end]
    
    if chr_row == chr_col:
        if bin_size >= 1000000:
            bin_size_str = str(bin_size/1000000)
            my_filename = 'HiCtool_' 'chr' + chr_row + '_' + bin_size_str + 'mb_' + data_type + '.txt'
        elif bin_size < 1000000:
            bin_size_str = str(bin_size/1000)
            my_filename = 'HiCtool_' 'chr' + chr_row + '_' + bin_size_str + 'kb_' + data_type + '.txt'
        if save_output == True:
            save_matrix(output_matrix, my_filename)
    else:
        #dim_row = str(d_chr_dim[chr_row])
        #dim_col = str(d_chr_dim[chr_col])
        if bin_size >= 1000000:
            bin_size_str = str(bin_size/1000000)
            my_filename = 'HiCtool_' 'chr' + chr_row + '_chr' + chr_col + '_' + bin_size_str + 'mb_' + data_type + '.txt'
        elif bin_size < 1000000:
            bin_size_str = str(bin_size/1000)
            my_filename = 'HiCtool_' 'chr' + chr_row + '_chr' + chr_col + '_' + bin_size_str + 'kb_' + data_type + '.txt'
        if save_output == True:
            save_matrix_rectangular(output_matrix, my_filename)
    
    if save_tab == True:
        save_matrix_tab(output_matrix, my_filename.split('.')[0] + '_tab.txt')
    
    return output_matrix
    

def plot_map(input_matrix,
             isGlobal,
             tab_sep=False,
             chr_row='',
             chr_col='',
             bin_size=1000000,
             chr_row_coord=[],
             chr_col_coord=[],
             data_type='observed',
             species='hg38',
             custom_species=None,
             my_colormap=['white', 'red'],
             cutoff_type='perc',
             cutoff=99,
             max_color='#460000',
             my_dpi=2000,
             plot_histogram=False,
             topological_domains='',
             domain_color='#0000ff'):
    """
    Plot a contact map, either global or single map. To plot the global matrix leave "chr_row" and
    "chr_col" as empty strings.
    Arguments:
        input_matrix (object | str): contact matrix. This can be passed either as
        an object of the workspace or a string of the filename saved to file.
        isGlobal (bool): set to True if you are passing a global matrix (all-by-all chromosomes), False otherwise.
        tab_sep (bool): if "input_matrix" is passed with a filename, then this boolean 
        tells if the matrix was saved in tab separated format (True) or not (False).
        chr_row (str): chromosome in the rows of the output contact matrix.
        chr_col (str): chromosome in the columns of the output contact matrix. If chr_col is 
        equal to chr_row then the intrachromosomal map is extracted.
        bin_size (int): bin size in bp of the contact matrix.
        chr_row_coord (list): list of two integers with start and end coordinates for the chromosome on the rows to be plotted (only if a single map is selected).
        chr_col_coord (list): list of two integers with start and end coordinates for the chromosome on the columns to be plotted (only if a single map is selected).
        data_type (str): which kind of data type you are extracting ("observed" or "normalized").
        species (str): 'hg38' or 'mm10' or any other species label in string format.
        custom_species (str): "/path/filename.txt". Tab separated file for chromosomes of the custom species. 
        Each row of the file is a chromosome: first column chromosome name with chr label (example:chrA); 
        second column chromosome size.
        my_colormap (str | list): colormap to be used to plot the data. 1) Use a string if you choose among any colorbar here 
        https://matplotlib.org/examples/color/colormaps_reference.html 2) Use a list of strings with colors if you want
        a custom colorbar. Example: ['white', 'red', 'black']. Colors can be specified also in this format: '#000000'.
        cutoff_type (str): to select a type of cutoff ('percentile' or 'contact_number') or plot the full range of the data (set the 
        parameter as None).
        cutoff (int): percentile to set a maximum cutoff on the number of contacts for the colorbar.
        max_color (str): to set the color of the bins with contact counts over "cutoff".
        my_dpi (int): resolution of the contact map in dpi.
        plot_histogram (bool): if True, plot the contact data distribution (only if a single map is selected).
        topological_domains (str | obj): topological domain coordinates to visualize domains on the heatmap. 
        They can be passed either as a txt file or object (as generated from HiCtool_TAD_analysis.py) If empty string, no topological domains (only if a single map is selected).
        domain_color (str): to set the color for topological domains on the heatmap. 
    Outputs:
        Heatmap saved in pdf format.
        Histogram saved in pdf format if "plot_histogram=True".
    """         
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    from matplotlib.colors import LinearSegmentedColormap
    import numpy as np
    import copy
    
    if species in chromosomes.keys():
        chromosomes_list = [str(i) for i in range(len(chromosomes[species]) - 1)[1:]] + ['X', 'Y']
        chr_dim = []
        for i in chromosomes_list:
            chr_dim.append(chromosomes[species][i]/bin_size) 
        d_chr_dim = {}
        for i in chromosomes_list:
            d_chr_dim[i] = chromosomes[species][i]/bin_size
    else:
        custom_chromosomes = open(custom_species, 'r')
        chromosomes_list = []
        chr_dim = []
        d_chr_dim = {}
        while True:
            try:
                line2list = next(custom_chromosomes).split('\n')[0].split('\t')
                chromosomes_list.append(line2list[0].replace('chr',''))
                chr_dim.append(int(line2list[1])/bin_size) 
                d_chr_dim[line2list[0].replace('chr','')] = int(line2list[1])/bin_size
            except StopIteration:
                break
    
    d_chr_dim_inc = {}
    k=1
    for i in chromosomes_list:
        d_chr_dim_inc[i] = sum(chr_dim[:k])
        k+=1
    
    d_chr_label_pos = {} # label position for chromosomes in the global matrix
    k = 0 # to consider the pixel occupied by the grid added after
    for i in chromosomes_list:
        d_chr_label_pos[i] = d_chr_dim_inc[i] - d_chr_dim[i]/2 + k
        k+=2
    
    label_pos = []
    label_name = []
    for i in chromosomes_list:
        label_pos.append(d_chr_label_pos[i])
        label_name.append('chr' + i)
    label_pos = np.array(label_pos)
    label_name = tuple(label_name)
    
    # Plot global heatmap
    if chr_row == '' and chr_col == '':
        if bin_size >= 1000000:
            bin_size_str = str(bin_size/1000000) + 'mb'
            my_filename = 'HiCtool_' + bin_size_str + '_' + data_type
        elif bin_size < 1000000:
            bin_size_str = str(bin_size/1000) + 'kb'
            my_filename = 'HiCtool_' + bin_size_str + '_' + data_type     
        
        if isinstance(input_matrix,str):
            if tab_sep == False:
                matrix_data_full = load_matrix(input_matrix)
            else:
                matrix_data_full = load_matrix_tab(input_matrix)
        else:
            matrix_data_full = copy.deepcopy(input_matrix)
        
        print "Plotting..."
        # Adding grid to separate chromosomes
        k=0
        for i in chromosomes_list[:-1]:
            matrix_data_full = np.insert(matrix_data_full, d_chr_dim_inc[i]+k, -1, axis=1)
            matrix_data_full = np.insert(matrix_data_full, d_chr_dim_inc[i]+k, -1, axis=0)
            matrix_data_full = np.insert(matrix_data_full, d_chr_dim_inc[i]+k, -1, axis=1)
            matrix_data_full = np.insert(matrix_data_full, d_chr_dim_inc[i]+k, -1, axis=0)
            k += 2
        
        row = np.shape(matrix_data_full)[0]
        col = np.shape(matrix_data_full)[1]
        
        output_vect = np.reshape(matrix_data_full,row*col,1)
        negative_indexes = np.where(output_vect==-1)
        output_vect[negative_indexes] = 0
        non_zero = np.nonzero(output_vect)
        
        if isinstance(my_colormap, list):
            my_cmap = LinearSegmentedColormap.from_list('mycmap', my_colormap)
        elif isinstance(my_colormap, str):
            my_cmap = my_colormap
        
        plt.close("all")
        
        if cutoff_type == 'perc':
            perc = np.percentile(output_vect[non_zero[0]],cutoff)
            plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmax=perc , vmin=0)
            cbar = plt.colorbar(extend='max')
            cbar.cmap.set_over(max_color)
        elif cutoff_type == 'contact':
            perc = cutoff 
            plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmax=perc , vmin=0)
            cbar = plt.colorbar(extend='max')
            cbar.cmap.set_over(max_color)
        elif cutoff_type == None:
            plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmin=0)
            cbar = plt.colorbar()
            
        cbar.cmap.set_under('black')   
        cbar.ax.set_ylabel(data_type + ' contact counts', rotation=270, labelpad=20)
        plt.title(data_type + ' contact map (' + bin_size_str + ')', fontsize=12)
        plt.xticks(label_pos, label_name, rotation='vertical', fontsize = 6)
        plt.yticks(label_pos, label_name, fontsize = 6)
        plt.tick_params(axis='both', which='both', length=0)
        plt.savefig(my_filename + '.pdf', format = 'pdf', dpi=my_dpi)
        print "Done!"
    
    # Plot a single heatmap
    if (chr_row != '' and chr_col == '') or (chr_row == '' and chr_col != ''):
        print "ERROR! Both the chromosomes have to be declared."
        return
    if chr_row != '' and chr_col != '':
        if isGlobal == True:
            matrix_data_full = extract_single_map(input_matrix,tab_sep,chr_row,chr_col,species,bin_size,data_type,custom_species,False,False)
        else:
            if isinstance(input_matrix,str):
                if tab_sep == True:
                    matrix_data_full = load_matrix_tab(input_matrix)
                else:
                    if chr_row == chr_col:
                        matrix_data_full = load_matrix(input_matrix)
                    else:
                        matrix_data_full = load_matrix_rectangular(input_matrix)
            else:
                matrix_data_full = copy.deepcopy(input_matrix)
    
        print "Plotting..."        
        chromosome_row = 'chr' + chr_row
        chromosome_col = 'chr' + chr_col        
        
        if bin_size >= 1000000:
            bin_size_str = str(bin_size/1000000) + 'mb'
            my_filename = 'HiCtool_' + chromosome_row + '_' + chromosome_col + '_' + bin_size_str + '_' + data_type
        elif bin_size < 1000000:
            bin_size_str = str(bin_size/1000) + 'kb'
            my_filename = 'HiCtool_' + chromosome_row + '_' + chromosome_col + '_' + bin_size_str + '_' + data_type
        
        # Update matrix values to plot topological domains
        if topological_domains != '':
            if chr_row != chr_col:
                print "ERROR! To plot topological domains the matrix should be intrachromosomal"
                return
            if chr_row == '' and chr_col == '':
                print "ERROR! To plot topological domains select a single intrachromosomal contact matrix. Use chr_row and chr_col for that."
                return
            if isinstance(topological_domains, str):
                domains = load_topological_domains(topological_domains)
            else:
                domains = topological_domains
            my_filename = my_filename + '_domains'
            diag_index = np.diag_indices(len(matrix_data_full))
            for domain in domains:
                temp_start = domain[0]/bin_size
                temp_end = domain[1]/bin_size
                matrix_data_full[temp_start,temp_start:temp_end] = -1
                matrix_data_full[temp_start:temp_end,temp_end-1] = -1
                matrix_data_full[(diag_index[0][temp_start:temp_end],diag_index[1][temp_start:temp_end])] = -1
        
        # Selecting a part of a single heatmap
        if len(chr_row_coord) > 0 or len(chr_col_coord) > 0:
            if len(chr_row_coord) == 0:
                print "ERROR! Coordinates on the chromosome on the rows should be declared (no empty chr_row_coord)."
                return
            if len(chr_col_coord) == 0:
                print "ERROR! Coordinates on the chromosome on the cols should be declared (no empty chr_col_coord)."
                return
            if len(chr_row_coord) == 1 or len(chr_col_coord) == 1:
                print "ERROR! Start and end coordinate for each chromosome should be declared."
                return
            if len(chr_row_coord) > 2 or len(chr_col_coord) > 2:
                print "ERROR! Only two coordinates (start and end) for each chromosome should be declared."
                return
            if len(chr_row_coord) == 2 or len(chr_col_coord) == 2:
                chr_row_bin = map(lambda x: x/bin_size, chr_row_coord)
                chr_col_bin = map(lambda x: x/bin_size, chr_col_coord)
        
                if chr_row_coord[0] >= chr_row_coord[1] or chr_col_coord[0] >= chr_col_coord[1]:
                    print "ERROR! Start coordinate should be lower than end coordinate"
                    return
                if chr_row_bin[0] >= chr_row_bin[1] or chr_col_bin[0] >= chr_col_bin[1]:
                    print "ERROR! Start coordinate should be much lower than the end coordinate given the bin size"
                    return
                if chr_row_bin[1] > d_chr_dim[chr_row]:
                    print "ERROR! End coordinate of the chromosome on the rows should be lower than the chromosome size"
                    return
                if chr_col_bin[1] > d_chr_dim[chr_col]:
                    print "ERROR! End coordinate of the chromosome on the cols should be lower than the chromosome size"
                    return
                
                matrix_data_full = matrix_data_full[chr_row_bin[0]:chr_row_bin[1]+1,chr_col_bin[0]:chr_col_bin[1]+1]
                
        row = np.shape(matrix_data_full)[0]
        col = np.shape(matrix_data_full)[1]
        
        output_vect = np.reshape(matrix_data_full,row*col,1)
        non_zero = np.nonzero(output_vect)
        
        if isinstance(my_colormap, list):
            my_cmap = LinearSegmentedColormap.from_list('mycmap', my_colormap)
        elif isinstance(my_colormap, str):
            my_cmap = my_colormap
        
        def format_e(n):
            a = '%e' % n
            return a.split('e')[0].rstrip('0').rstrip('.') + 'e' + a.split('e')[1]        
        
        plt.close("all")
        plt.gcf().subplots_adjust(left=0.15)
        plt.gcf().subplots_adjust(bottom=0.15)
        
        if cutoff_type == 'perc':
            perc = np.percentile(output_vect[non_zero[0]],cutoff)
            if topological_domains == '':
                plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmax=perc)
                cbar = plt.colorbar(extend='max')
                cbar.cmap.set_over(max_color)
            else:
                plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmax=perc, vmin=0)
                cbar = plt.colorbar(extend='max')
                cbar.cmap.set_over(max_color)
                cbar.cmap.set_under(domain_color)
        elif cutoff_type == 'contact':
            perc = cutoff 
            if topological_domains == '':
                plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmax=perc)
                cbar = plt.colorbar(extend='max')
                cbar.cmap.set_over(max_color)
            else:
                plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmax=perc, vmin=0)
                cbar = plt.colorbar(extend='max')
                cbar.cmap.set_over(max_color)
                cbar.cmap.set_under(domain_color)
        elif cutoff_type == None:
            if topological_domains == '':
                plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest')
                cbar = plt.colorbar()
            else:
                plt.imshow(matrix_data_full, cmap=my_cmap, interpolation='nearest', vmin=0)
                cbar = plt.colorbar()
                cbar.cmap.set_under(domain_color)
        
        plt.title(data_type + ' contact map (' + bin_size_str + ')', fontsize=12)
        cbar.ax.set_ylabel(data_type + ' contact counts', rotation=270, labelpad=20)
        plt.ylabel(chromosome_row + ' coordinate (bp)', fontsize=10)
        plt.xlabel(chromosome_col + ' coordinate (bp)', fontsize=10)
        if len(chr_row_coord) == 2 and len(chr_col_coord) == 2:
            ticks_row = (np.arange(0, row, row/4) * bin_size) + chr_row_coord[0]
            ticks_col = (np.arange(0, col, col/4) * bin_size) + chr_col_coord[0]
            format_ticks_row = [format_e(i) for i in ticks_row.tolist()]
            format_ticks_col = [format_e(i) for i in ticks_col.tolist()]
            plt.yticks(np.arange(0, row, row/4), format_ticks_row)
            plt.xticks(np.arange(0, col, col/4), format_ticks_col)
        else:
            ticks_row = (np.arange(0, row, row/4) * bin_size)
            ticks_col = (np.arange(0, col, col/4) * bin_size)
            format_ticks_row = [format_e(i) for i in ticks_row.tolist()]
            format_ticks_col = [format_e(i) for i in ticks_col.tolist()]
            plt.yticks(np.arange(0, row, row/4), format_ticks_row)
            plt.xticks(np.arange(0, col, col/4), format_ticks_col)
        plt.tick_params(axis='both', which='both', direction='out', top=False, right=False)
        plt.xticks(fontsize=8)
        plt.yticks(fontsize=8)
        plt.savefig(my_filename + '.pdf', format = 'pdf', dpi=my_dpi)
        
        # Plot of the histogram
        if plot_histogram:
            histogram = []
            if chr_row == chr_col:
                n = len(matrix_data_full)
                k = 1
                for i in xrange(n):
                    row = matrix_data_full[i][k:]
                    for j in row:
                        histogram.append(j)
                    k += 1
            else:
                histogram = matrix_data_full.reshape((1,row*col)).tolist()[0]
                
            plt.close("all")
            histogram_bins = int(pow(len(histogram),0.3))
            plt.hist(histogram, bins=histogram_bins)
            plt.title(data_type + ' contact counts distribution', fontsize=18)
            plt.xlabel(data_type + ' contact counts', fontsize=16)
            plt.ylabel('Number of bins', fontsize=16)
            plt.xticks(fontsize=16)
            plt.yticks(fontsize=16)
            plt.tight_layout()
            plt.savefig(my_filename + '_histogram.pdf', format = 'pdf')
        
        print "Done!"
        
def plot_timeline_map(inputFiles,
                      outputFile,
                      tab_sep,
                      chr_row,
                      chr_col,
                      time_points,
                      bin_size,
                      data_type,
                      species='hg38',
                      custom_species=None,
                      my_colormap=['white','red'],
                      cutoff_type='perc',
                      cutoff=95,
                      max_color='#460000',
                      my_dpi=2000,
                      topological_domains=None,
                      domain_color='#0000ff'):
    
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    from matplotlib.colors import LinearSegmentedColormap
    import numpy as np
    
    # Different width for the grid to separate contact maps at different resolutions in order to be well visualized in the plots
    if bin_size > 200000:
        grid_width = 2
    elif bin_size <= 200000 and bin_size > 100000:
        grid_width = 4
    elif bin_size <= 100000 and bin_size > 50000:
        grid_width = 8
    elif bin_size <= 50000:
        grid_width = 16
    
    if species in chromosomes.keys():
        chromosomes_list = [str(i) for i in range(len(chromosomes[species]) - 1)[1:]] + ['X', 'Y']
        chr_dim = []
        for i in chromosomes_list:
            chr_dim.append(chromosomes[species][i]/bin_size)
        d_chr_dim = {}
        for i in chromosomes_list:
            d_chr_dim[i] = chromosomes[species][i]/bin_size
    else:
        custom_chromosomes = open(custom_species, 'r')
        chromosomes_list = []
        chr_dim = []
        d_chr_dim = {}
        while True:
            try:
                line2list = next(custom_chromosomes).split('\n')[0].split('\t')
                chromosomes_list.append(line2list[0].replace('chr',''))
                chr_dim.append(int(line2list[1])/bin_size)
                d_chr_dim[line2list[0].replace('chr','')] = int(line2list[1])/bin_size
            except StopIteration:
                break
            
    d_chr_dim_inc = {}
    k=1
    for i in chromosomes_list:
        d_chr_dim_inc[i] = sum(chr_dim[:k])
        k+=1
    
    label_pos = []
    label_name = []
    last_pos = 0
    n = 0
    for chr_r,chr_c in zip(chr_row,chr_col):
        if n == 0:
            label_pos.append(d_chr_dim[chr_r]/2)
            last_pos += d_chr_dim[chr_r] + grid_width # to consider the grid
            n+=1
        else:
            label_pos.append(last_pos + d_chr_dim[chr_r]/2)
            last_pos += d_chr_dim[chr_r] + grid_width
             
        if chr_r == chr_c:
            label_name.append('chr' + chr_r)
        else:
            label_name.append('chr' + chr_r + '-chr' + chr_c)
    label_pos = np.array(label_pos)
    label_name = tuple(label_name)
    
    if len(my_colormap) > 1:
        my_cmap = LinearSegmentedColormap.from_list('mycmap', my_colormap)
    elif len(my_colormap) == 1:
        my_cmap = my_colormap[0]
    
    if bin_size >= 1000000:
        bin_size_str = str(bin_size/1000000) + 'mb'
        my_filename = 'HiCtool_time' + bin_size_str + '_' + data_type
    elif bin_size < 1000000:
        bin_size_str = str(bin_size/1000) + 'kb'
        my_filename = 'HiCtool_time' + bin_size_str + '_' + data_type
    
    # From global heatmap
    # Load each global map at every time point into a dictionary
    inputFiles_dict = dict()
    for i in range(len(inputFiles)):
        if tab_sep == False:
            matrix_data_full = load_matrix(inputFiles[i])
        else:
            matrix_data_full = load_matrix_tab(inputFiles[i])
        inputFiles_dict[time_points[i]] = matrix_data_full

    time_steps = np.linspace(0,len(chr_row),11).astype(int).tolist() # to print percentage of completion to console


    print "(1/2) Building the matrix..."
    counter = 0 # to print percentage of completion to console
    init_counter = 0 # counter to initialize the output full matrix (if equal 1) or not
    n_col_list = [] # to save the uumber of columns in each row
    n_col_max = max([d_chr_dim[x] for x in chr_col]) * len(time_points) + (len(time_points)-1)*grid_width # to consider the grid
    for key, value in d_chr_dim.items():
        if value == max([d_chr_dim[x] for x in chr_col]):
            chr_col_max = key # bigger chromosomes in the columns
    output_full_matrix = np.zeros((1,n_col_max)) # initialize matrix so I can concatenate already a line where the chromosome in the columns is not the biggest
    for i,j in zip(chr_row, chr_col):
        init_counter += 1
        line_dict = dict() # to save the contact matrices per each line
        for k in time_points:
            # Extract the single map
            if i == '1':
                row_start = 0
            else:
                row_start = d_chr_dim_inc[chromosomes_list[chromosomes_list.index(i)-1]]
            row_end = row_start + d_chr_dim[i]
            
            if j == '1':
                col_start = 0
            else:
                col_start = d_chr_dim_inc[chromosomes_list[chromosomes_list.index(j)-1]]
            col_end = col_start + d_chr_dim[j]
            
            input_matrix_array = inputFiles_dict[k] # global map at the k time point
            output_matrix = input_matrix_array[row_start:row_end,col_start:col_end]
            
            line_dict[k] = output_matrix # fill in the dictionary with each matrix per time point for this line
        
        # Build the line
        matrix_line = line_dict[time_points[0]] # initialize the line with the first matrix
        n_row = np.shape(matrix_line)[0]
        sep_col = np.zeros((n_row,grid_width))-1
        if j == chr_col_max: # I do not add the last sep_col since it's going till the full width of the heatmap
            for t in range(len(time_points))[1:]:
                matrix_line = np.concatenate((matrix_line,sep_col,line_dict[time_points[t]]), axis=1)
        else: # for the other chromosomes that are shorter I add the last sep_col
            for t in range(len(time_points))[1:]:
                if t != len(time_points)-1:
                    matrix_line = np.concatenate((matrix_line,sep_col,line_dict[time_points[t]]), axis=1)
                else: # another sep_col is added at the end
                    matrix_line = np.concatenate((matrix_line,sep_col,line_dict[time_points[t]],sep_col), axis=1)
        
        # Attach the row to the output full matrix
        if init_counter == 1: # initialize the output full matrix
            n_col = np.shape(matrix_line)[1]
            diff_col = n_col_max - n_col
            matrix_line_full = np.concatenate((matrix_line,np.zeros((n_row,diff_col))), axis=1)
            output_full_matrix = np.concatenate((output_full_matrix,matrix_line_full), axis=0)
            n_col_list.append(n_col)
        else:
            n_col = np.shape(matrix_line)[1]
            diff_col = n_col_max - n_col
            matrix_line_full = np.concatenate((matrix_line,np.zeros((n_row,diff_col))), axis=1)
            if n_col < n_col_list[-1]: # the chromosome length is smaller than the previous chromosomes
                sep_row = np.concatenate((np.zeros((grid_width,n_col_list[-1]))-1,np.zeros((grid_width,n_col_max-n_col_list[-1]))), axis=1)
            else:
                sep_row = np.concatenate((np.zeros((grid_width,n_col))-1,np.zeros((grid_width,diff_col))), axis=1)
            n_col_list.append(n_col)
            output_full_matrix = np.concatenate((output_full_matrix,sep_row,matrix_line_full), axis=0)
        
        counter += 1
        for i in range(len(time_steps)):
            if counter == time_steps[i]:
                print str(i*10) + '% completed.'

    print "(1/2) Done!"

    print "(2/2) Plotting..."
    
    output_full_matrix = output_full_matrix[1::]
    row = np.shape(output_full_matrix)[0]
    col = np.shape(output_full_matrix)[1]
    
    output_vect = np.reshape(output_full_matrix,row*col,1)
    negative_indexes = np.where(output_vect==-1)
    output_vect[negative_indexes] = 0
    non_zero = np.nonzero(output_vect)
    
    plt.close("all")
    
    if cutoff_type == 'perc':
        perc = np.percentile(output_vect[non_zero[0]],cutoff)
        plt.imshow(output_full_matrix, cmap=my_cmap, interpolation='nearest', vmax=perc , vmin=0)
        cbar = plt.colorbar(extend='max')
        cbar.cmap.set_over(max_color)
    elif cutoff_type == 'contact':
        perc = cutoff 
        plt.imshow(output_full_matrix, cmap=my_cmap, interpolation='nearest', vmax=perc , vmin=0)
        cbar = plt.colorbar(extend='max')
        cbar.cmap.set_over(max_color)
    elif cutoff_type == None:
        plt.imshow(output_full_matrix, cmap=my_cmap, interpolation='nearest', vmin=0)
        cbar = plt.colorbar()
    
    cbar.cmap.set_under('black')   
    cbar.ax.set_ylabel(data_type + ' contact counts', rotation=270, labelpad=20)
    plt.title(data_type + ' map (' + bin_size_str + ')', fontsize=12)
    sample_pos_k = [0.5,1.5]
    if len(time_points) > 2:
        for i in xrange(len(time_points[2:])):
            sample_pos_k.append(sample_pos_k[-1]+1)
    sample_pos = np.array([int(x*d_chr_dim[chr_col_max]) for x in sample_pos_k])
    plt.xticks(sample_pos, tuple(time_points), fontsize = 6)
    plt.yticks(label_pos, label_name, fontsize = 6)
    plt.tick_params(axis='both', which='both', length=0)
    if outputFile == None:
        plt.savefig(my_filename + '.pdf', format = 'pdf', dpi=my_dpi)
    else:
        plt.savefig(outputFile, format = 'pdf', dpi=my_dpi)

    print "(2/2) Done!"